import type { FC } from 'react'
import {
  SchemaField,
  RichTextField,
  ReferenceField,
  ObjectField,
  RichTextTemplate,
} from '../types'

export type { RichTextTemplate }
export type ObjectType<WithNamespace extends boolean = false> =
  ObjectField<WithNamespace>
export type RichTextType<WithNamespace extends boolean = false> =
  RichTextField<WithNamespace>
export type ReferenceType<WithNamespace extends boolean = false> =
  ReferenceField & MaybeNamespace<WithNamespace>

/**
 * @deprecated use Config instead
 */
export type TinaCloudSchemaConfig<DeleteMe = undefined> = Config

type TokenObject = {
  id_token: string
  access_token?: string
  refresh_token?: string
}

export interface Config<
  CMSCallback = undefined,
  FormifyCallback = undefined,
  DocumentCreatorCallback = undefined,
  Store = undefined
> {
  contentApiUrlOverride?: string
  admin?: {
    auth?: {
      /**
       * If you wish to use the local auth provider, set this to true
       *
       * This will take precedence over the customAuth option (if set to true)
       *
       **/
      useLocalAuth?: boolean
      /**
       * If you are using a custom auth provider, set this to true
       **/
      customAuth?: boolean
      /**
       *  Used for getting the token from the custom auth provider
       *
       * @returns {Promise<TokenObject | null>}
       **/
      getToken?: () => Promise<TokenObject | null>
      /**
       *  Used to logout from the custom auth provider
       *
       **/
      logout?: () => Promise<void>
      /**
       *  Used for getting the user from the custom auth provider. If this returns a truthy value, the user will be logged in and the CMS will be enabled.
       *
       *  If this returns a falsy value, the user will be logged out and the CMS will be disabled.
       *
       **/
      getUser?: () => Promise<any | null>
      /**
       * Used to authenticate the user with the custom auth provider. This is called when the user clicks the login button.
       *
       **/
      authenticate?: () => Promise<any | null>

      onLogin?: (args: { token: TokenObject }) => Promise<void>
      onLogout?: () => Promise<void>
    }
  }
  // schema: TinaCloudSchema<false>
  /**
   * The Schema is used to define the shape of the content.
   *
   * https://tina.io/docs/reference/schema/
   */
  schema: Schema
  /**
   * The base branch to pull content from. Note that this is ignored for local development
   */
  branch: string | null
  /**
   * Your clientId from  app.tina.io
   */
  clientId: string | null
  /**
   * Your read only token from app.tina.io
   */
  token: string | null
  /**
   * Configurations for the autogenerated GraphQL HTTP client
   */
  client?: {
    /**
     * Autogenerated queries will traverse references to a given depth
     * @default 2
     */
    referenceDepth?: number
  }
  /**
   *
   * Tina supports serving content from a separate Git repo. To enable this during local development, point
   * this config at the root of the content repo.
   *
   * NOTE: Relative paths are fine to use here, but you should use an environment variable for this, as each developer on your team may have a different
   * location to the path.
   *
   * ```ts
   * localContentPath: process.env.REMOTE_ROOT_PATH // eg. '../../my-content-repo'
   * ```
   */
  localContentPath?: string
  /**
   * Tina is compiled as a single-page app and placed in the public directory
   * of your application.
   */
  build: {
    /**
     * The folder where your application stores assets, eg. `"public"`
     */
    publicFolder: string
    /**
     * The value specified here will determine the path when visiting the TinaCMS dashboard.
     *
     * Eg. `"admin"` will be viewable at `[your-development-url]/admin/index.html`
     *
     * Note that for most framworks you can omit the `index.html` portion, for Next.js see the [rewrites section](https://nextjs.org/docs/api-reference/next.config.js/rewrites)
     */
    outputFolder: string
    /**
     *
     *  the host option for the vite config. This is useful when trying to run tinacms dev in a docker container.
     *
     * See https://vitejs.dev/config/server-options.html#server-host for more details
     */
    host?: string | boolean
  }
  media?:
    | {
        /**
         * Load a media store like Cloudinary
         *
         * ```ts
         * loadCustomStore = async () => {
         *   const pack = await import("next-tinacms-cloudinary");
         *   return pack.TinaCloudCloudinaryMediaStore;
         * }
         * ```
         */
        loadCustomStore: () => Promise<Store>
        tina?: never
      }
    | {
        /**
         * Use Git-backed assets for media, these values will
         * [Learn more](https://tina.io/docs/reference/media/repo-based/)
         */
        tina: {
          /**
           * The folder where your application stores assets, eg. `"public"`
           */
          publicFolder: string
          /**
           * The root folder for media managed by Tina. For example, `"uploads"`
           * would store content in `"<my-public-folder>/uploads"`
           */
          mediaRoot: string
        }
        loadCustomStore?: never
      }
  /**
   * Used to override the default Tina Cloud API URL
   *
   * [mostly for internal use only]
   */
  tinaioConfig?: {
    assetsApiUrlOverride?: string // https://assets.tinajs.io
    frontendUrlOverride?: string // https://app.tina.io
    identityApiUrlOverride?: string // https://identity.tinajs.io
    contentApiUrlOverride?: string // https://content.tinajs.io
  }
  cmsCallback?: CMSCallback
  formifyCallback?: FormifyCallback
  documentCreatorCallback?: DocumentCreatorCallback
}
export type TinaCMSConfig<
  CMSCallback = undefined,
  FormifyCallback = undefined,
  DocumentCreatorCallback = undefined,
  Store = undefined
> = Config<CMSCallback, FormifyCallback, DocumentCreatorCallback, Store>

type UIField<F extends UIField = any, Shape = any> = {
  // name?: string
  label?: string | boolean
  description?: string
  // TODO type component
  component?: FC<any> | string | null
  // inlineComponent?: FC<any>
  parse?: (value: Shape, name: string, field: F) => any
  format?: (value: Shape, name: string, field: F) => any
  validate?(
    value: Shape,
    allValues: any,
    meta: any,
    field: UIField<F, Shape>
  ): string | object | undefined | void
  /**
   * @deprecated use `defaultItem` at the collection level instead
   */
  defaultValue?: Shape
}

/** @deprecated use Schema instead */
export type TinaCloudSchema<WithNamespace extends boolean = false> =
  Schema<WithNamespace>

export interface Schema<WithNamespace extends boolean = false> {
  /**
   * Collections represent a type of content (EX, blog post, page, author, etc). We recommend using singular naming in a collection (Ex: use post and not posts).
   *
   * https://tina.io/docs/reference/collections/
   */
  collections: Collection<WithNamespace>[]
  /**
   * @deprecated use `defineConfig` in a config.{js,ts} file instead
   */
  config?: Config
}

type MaybeNamespace<WithNamespace extends boolean> = WithNamespace extends true
  ? { namespace: string[] }
  : {}

export type Collection<WithNamespace extends boolean = false> =
  | FieldCollection<WithNamespace>
  | TemplateCollection<WithNamespace>

interface BaseCollection {
  label?: string
  name: string
  path: string
  indexes?: IndexType[]
  format?: 'json' | 'md' | 'markdown' | 'mdx' | 'yaml' | 'yml' | 'toml'
  ui?: UICollection
  /**
   * @deprecated - use `ui.defaultItem` on the each `template` instead
   */
  defaultItem?: DefaultItem<Record<string, any>>
  /**
   * This format will be used to parse the markdown frontmatter
   */
  frontmatterFormat?: 'yaml' | 'toml' | 'json'
  /**
   * The delimiters used to parse the frontmatter.
   */
  frontmatterDelimiters?: [string, string] | string
  match?: string
}

type TemplateCollection<WithNamespace extends boolean> = {
  /**
   * In most cases, just using fields is enough, however templates can be used when there are multiple variants of the same collection or object. For example in a "page" collection there might be a need for a marketing page template and a content page template, both under the collection "page".
   *
   * https://tina.io/docs/reference/templates/
   */
  templates: Template<WithNamespace>[]
  fields?: undefined
} & BaseCollection &
  MaybeNamespace<WithNamespace>

type FieldCollection<WithNamespace extends boolean> = {
  /**
   * Fields define the shape of the content and the user input.
   *
   * https://tina.io/docs/reference/fields/
   */
  fields: TinaField<WithNamespace>[]
  templates?: undefined
} & BaseCollection &
  MaybeNamespace<WithNamespace>

/** @deprecated use Collection instead */
export type TinaCloudCollection<WithNamespace extends boolean> =
  Collection<WithNamespace>

type Document = {
  _sys: {
    title?: string
    template: string
    breadcrumbs: string[]
    path: string
    basename: string
    relativePath: string
    filename: string
    extension: string
  }
}
export interface UICollection {
  /**
   * Customize the way filenames are generated during content creation
   */
  filename?: {
    /**
     * A callback which receives form values as an argument. The return value
     * here will be used as the filename (the extension is not necessary)
     *
     * eg:
     * ```ts
     * slugify: (values) => values.title.toLowerCase().split(" ").join("-")
     * ```
     */
    slugify?: (values: Record<string, any>) => string
    /**
     * When set to `true`, editors won't be able to modify the filename
     */
    readonly?: boolean
  }
  /**
   * Determines whether or not this collection can accept new docments
   * or allow documents to be deleted from the CMS.
   */
  allowedActions?: {
    create?: boolean
    delete?: boolean
  }
  /**
   * Forms for this collection will be editable from the global sidebar rather than the form panel
   */
  global?: boolean | { icon?: any; layout: 'fullscreen' | 'popup' }
  /**
   * Provide the path that your document is viewable on your site
   *
   * eg:
   * ```ts
   * router: ({ document }) => {
   *   return `blog-posts/${document._sys.filename}`;
   * }
   * ```
   */
  router?: (args: {
    document: Document
    collection: Collection<true>
  }) => string | undefined
}

export type DefaultItem<ReturnType> = ReturnType | (() => ReturnType)

type IndexType = {
  name: string
  fields: {
    name: string
  }[]
}

/** @deprecated use Template instead */
export type TinaTemplate = Template<false>

export type TinaField<WithNamespace extends boolean = false> =
  SchemaField<WithNamespace> & MaybeNamespace<WithNamespace>

export type Option =
  | string
  | {
      label?: string
      icon?: FC
      value: string
    }

export type UITemplate = {
  /**
   * Override the properties passed to the field
   * component. This is mostly useful for controlling
   * the display value via callback on `itemProps.label`
   */
  itemProps?(item: Record<string, any>): {
    key?: string
    /**
     * Control the display value when object
     * items are shown in a compact list, eg:
     *
     * ```ts
     * itemProps: (values) => ({
     *   label: values?.title || 'Showcase Item',
     * }),
     * ```
     */
    label?: string | boolean
  }
  defaultItem?: DefaultItem<Record<string, any>>
  /**
   * When used in relation to the `visualSelector`,
   * provide an image URL to be used as the preview
   * in the blocks selector menu
   */
  previewSrc?: string
}

/**
 * Templates allow you to define an object as polymorphic
 */
export type Template<WithNamespace extends boolean = false> = {
  label?: string | boolean
  name: string
  ui?: UITemplate
  fields: TinaField<WithNamespace>[]
} & MaybeNamespace<WithNamespace>

// Builder types
export type CollectionTemplateableUnion = {
  namespace: string[]
  type: 'union'
  templates: Template<true>[]
}
export type CollectionTemplateableObject = {
  namespace: string[]
  type: 'object'
  visualSelector?: boolean
  ui?: UIField<any, Record<string, any>> & {
    itemProps?(item: Record<string, any>): {
      key?: string
      label?: string | boolean
    }
    defaultItem?: DefaultItem<Record<string, any>>
  }
  required?: false
  template: Template<true>
}
export type CollectionTemplateable =
  | CollectionTemplateableUnion
  | CollectionTemplateableObject

export type Collectable = Pick<
  Collection<true>,
  'namespace' | 'templates' | 'fields' | 'name'
> & { label?: string | boolean }
